from loguru import logger
import psycopg
from psycopg.cursor import Cursor

from mia.structs.user import User
from .migrations import Migrator
from dataclasses import dataclass
from mia.util.auth import hash as pwd_hash_func
from secrets import token_urlsafe

class ArchiveRecord:
    url: str
    timestamp: str
    status_code: int

    type: str = "web"

@dataclass
class DBConf:
    upgrade: bool = True
    _allow_unupgraded: bool = False

# It's probably not a good idea to keep a database monolith. But fuck you
# future me, this is your problem now
#
# I strongly doubt this will ever scale to the point where it becomes a problem
# though
class ArchiveDB:
    def __init__(self, dbname: str, dbhost: str, dbuser: str, dbpassword: str,
                 conf: DBConf):
        dbname = self.sanitise(dbname)
        dbhost = self.sanitise(dbhost)
        dbuser = self.sanitise(dbuser)
        dbpassword = self.sanitise(dbpassword)

        self.conf = conf
        self.connection_str = (f"dbname='{dbname}' user='{dbuser}' "
            f"password='{dbpassword}' host='{dbhost}'"
        )

        with self.connect() as conn:
            with conn.cursor() as c:
                migrator = Migrator(c)
                if not migrator.is_updated():
                    if conf.upgrade:
                        logger.debug("Running upgrade")
                        migrator.upgrade()
                    elif not conf._allow_unupgraded:
                        raise RuntimeError(
                            "You appear to be running a new CLI instance "
                            "without updating your server instance. "
                            "Please restart your server and try again"
                        )
                    else:
                        logger.warning(
                            "Skipping update; database may be inconsistent"
                        )

    def sanitise(self, a: str):
        # Per https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING-KEYWORD-VALUE
        # I think this won't be quite sufficient, but if anyone has a password
        # with not just single quotes, but backslashes immediately preceeding a
        # single quote, they're  bringing it on themselves.
        return (a
            .replace('\\', '\\\\')
            .replace("'", "\\'")
        )

    def get_user(
        self,
        cursor: Cursor,
        username: str,
        password: str
    ):
        results = cursor.execute(
            """
            SELECT UserID, Password, Salt, Admin FROM mia.Users
            WHERE Username = %s
            """,
            [ username ]
        ).fetchone()

        if results is None:
            return None

        (user_id, stored_hash, salt, is_admin) = results

        computed_hash = pwd_hash_func(
            password,
            salt
        )

        if (computed_hash != stored_hash):
            return False

        return User(
            username,
            user_id,
            is_admin
        )

    def create_user(
        self,
        cursor: Cursor,
        username: str,
        password: str,
        is_admin: bool
    ):
        """
        :param username     The username
        :param password     The raw password; hashing and the salt are
                            generated by this function, with
                            cryptographically secure methods
        :param is_admin     Whether or not the user is an admin. You should
                            probably set this to false
        """
        if cursor.execute(
            """
            SELECT 1 FROM mia.Users WHERE Username = %s
            """,
            [ username ]
        ).fetchone() is not None:
            return False

        # " As of 2015, it is believed that 32 bytes (256 bits) of randomness 
        # is sufficient for the typical use-case expected for the secrets 
        # module." - https://docs.python.org/3/library/secrets.html
        # So double it, because why the fuck not?
        # This is also approximately 83 bytes (64 * 1.3, because token_urlsafe
        # base64-encodes the bytes)
        salt = token_urlsafe(64)
        hashed_password = pwd_hash_func(password, salt)
        cursor.execute(
            """
            INSERT INTO mia.Users(Username, Password, Salt, Admin)
            VALUES (%s, %s, %s, %s)
            """,
            [ username, hashed_password, salt, is_admin ]
        )
        return True


    def connect(self):
        return psycopg.connect(self.connection_str)

    def _get_migration_version(self, cursor: Cursor):
        results = cursor.execute(
            "SELECT Version FROM mia.Migration WHERE Key = '__mia__'"
        ).fetchall()

        if len(results) == 1:
            return results[0][0]
        else:
            return None

